from math import log
import numba as nb
import numpy as np
from json import loads
import time
from enums.type_attack import TypeAttack
import random
from numba.experimental import jitclass
from numba import int32, float32, boolean, njit, objmode, types, gdb

width, height = (8, 16)

length_of_data_pawn = 1
SHOW_PRINT = False


@njit
def clear_file(f: str):
    with open(f + ".txt", "w"):
        pass



@njit
def print_file(f: str, args):
    arg = ""
    for a in args:
        arg += " " + str(a)
    with open(f + ".txt", "a") as file:
        file.write(arg + "\n")

@njit
def is_int(a):
    return int(a) == a

@njit
def is_power_or_root(a, b):
    if a <= 0 or b <= 0:
        if SHOW_PRINT:
            print("IS POWER OR ROOT ERROR", a, b)
        return
    if a == b:
        return True
    elif a == 1 or b == 1:
        return False
    return is_int(log(b) / log(a)) or is_int(log(a) / log(b))


@njit
def a_is_equation(a, b, c):
    return a + b == c \
        or abs(a - b) == c \
        or a * b == c \
        or a / b == c \
        or b / a == c


@njit
def get_progression(a, b, c):
    t = [a, b, c]
    t.sort()
    u, v, w = t
    if 2 * v == u + w:
        if SHOW_PRINT:
            print(f"aide: 2*{v} = {u}+{w}")
        return 1  # arithmétique
    if v * v == u * w:
        if SHOW_PRINT:
            print(f"aide: {v}*{v} = {u}*{w}")
        return 2  # géométrique
    if v * (u + w) == 2 * u * w:
        if SHOW_PRINT:
            print(f"aide: {v}*({u}+{w}) = 2*{u}*{w}")
        return 3  # harmonique
    return 0



@njit
def convert_to_numba_dict(original_dict):
    numba_dict = nb.typed.Dict.empty(key_type=types.int64, value_type=types.ListType(types.int64[:]))
    return numba_dict
    
t_locations = nb.typed.Dict.empty(
    key_type=int32,
    value_type=int32[:]
)

t_aim_value = np.array([[2], [2]])

t_aim = nb.typed.Dict.empty(
    key_type=int32,
    value_type=nb.typeof(t_aim_value)
)

t_shooter_value = np.array([[2], [2]])

t_shooter = nb.typed.Dict.empty(
    key_type=int32,
    value_type=nb.typeof(t_aim_value)
)

t_moves_by_id = nb.typed.Dict.empty(
    key_type=int32,
    value_type=int32[:]
)

double_int = nb.typeof(np.full((1, 1), 1))


# @njit

#define the dictionary types with Numba
spec = [
    ("board", nb.typeof(np.full((1, 1), 1))),
    ('turn', int32),
    ('player_turn', int32),
    ('width', int32),
    ('height', int32),
    ('stop', boolean),
    ('last_move', int32[:, :]),
    ('save_game', boolean),
    ('move_history', types.ListType(int32[:, :])),
    ('game_attacks', types.ListType(types.ListType(int32[:]))),
    ('locations', types.DictType(int32, int32[:])), 
    ('aim', types.DictType(int32, types.ListType(int32[:] ))),
    ('shooter', types.DictType(int32, types.ListType(int32[:] ))),
    ('value_by_id', int32[:]),
    ('form_by_id', int32[:]),
    ('team_by_id', int32[:]),
    ('moves_by_id', types.DictType(int32, types.DictType(int32, int32[:]))),
    ('pieces_in_opponent_site', int32[:, :]),
    ('iview', int32),
    ('winner', int32),
    ('initial_number_of_real_pieces', int32),
    ('initial_number_of_pieces', int32),
    ('BLACK_ID', int32[:]),
    ('WHITE_ID', int32[:]),

    ('ID_BLACK_PYRAMID', int32),
    ('FIRST_FAKE_ID_BLACK', int32),
    ('FAKE_ID_BLACK', int32[:]),

    ('ID_WHITE_PYRAMID', int32),
    ('FIRST_FAKE_ID_WHITE', int32),
    ('FAKE_ID_WHITE', int32[:])
]




@njit
def piece_number(self):
    nbr_white = sum(map(lambda i:is_alive(i), WHITE_ID))
    nbr_pyr_white = sum(map(lambda i:is_alive(i), FAKE_ID_WHITE))

    nbr_black = sum(map(lambda i:is_alive(i), BLACK_ID))
    nbr_pyr_black = sum(map(lambda i:is_alive(i), FAKE_ID_BLACK))
    #return (nbr_white, nbr_pyr_white, nbr_black, nbr_pyr_black)
    return (nbr_white + nbr_pyr_white, nbr_black + nbr_pyr_black)



@njit
def piece_rate(self):
    a,b = piece_number()
    return (a/30, b/29)



@njit
def piece_sum(self):
    sum_white = sum(map(lambda i:value_by_id(i), WHITE_ID))
    sum_pyr_white = sum(map(lambda i:value_by_id(i), FAKE_ID_WHITE))

    sum_black = sum(map(lambda i:value_by_id(i), BLACK_ID))
    sum_pyr_black = sum(map(lambda i:value_by_id(i), FAKE_ID_BLACK))
    return (sum_white + sum_pyr_white, sum_black + sum_pyr_black)



@njit
def isobarycenter(self, player):
    id_pawns = BLACK_ID if player else WHITE_ID
    x, y, n = 0, 0, 0
    for i in id_pawns:
        if is_alive(i):
            n=n+1
            y=locations[i][0] + y
            x=locations[i][1] + x
            
    return (y/n, x/n)
@njit
def distance_center_to_isobary_center(self, player):
    mid_y, mid_x = (7.5, 3.5)
    y, x = isobarycenter(player)
    return(y-mid_y, x-mid_x)

@njit
def dispersion(self, player):
    id_pawns = BLACK_ID if player else WHITE_ID
    ey, ex = isobarycenter(player)
    dx, dy, n = 0, 0, 0
    for i in id_pawns:
        if is_alive(i):
            n=n+1
            dy=(locations[i][0]-ey)**2 + dy
            dx=(locations[i][1]-ex)**2 + dx
    return (dy/n, dx/n)

@njit
def progress(self, player):
    id_pawns = BLACK_ID if player else WHITE_ID
    repere =  0 if player else 15
    y, n = 0, 0
    #print("player", player)
    for i in id_pawns:
        if is_alive(i):
            #print(repere)
            #print(i, ":", abs(repere - locations[i][1]))
            n=n+1
            y= abs(repere - locations[i][0]) + y
    
    return y

@njit
def get_delta_stats(self):

    white_pieces_rate, black_pieces_rate = piece_rate()
    (white_dispersion_y, white_dispersion_x), (black_dispersion_y, black_dispersion_x) = dispersion(0), dispersion(1)
    (white_dist_to_center_y, white_dist_to_center_x), (black_dist_to_center_y, black_dist_to_center_x) = distance_center_to_isobary_center(0), distance_center_to_isobary_center(1)
    white_progress, black_progress = progress(1), progress(0)
    return (white_pieces_rate - black_pieces_rate, 
            white_dispersion_y - black_dispersion_y,
            white_dispersion_x - black_dispersion_x,
            white_dist_to_center_y - black_dist_to_center_y,
            white_dist_to_center_x - black_dist_to_center_x,
            white_progress - black_progress)

@njit
def old_init_board(self):
    with objmode():

        print("test")
        f = open("./ex_module/id_board.json", "r")
        data = loads(f.read())
        f.close()

    board = np.array(data, dtype=int32)
    
# Vérifie si la position est bien dans le jeu
@njit
def in_board(self, j, i):
    return 0 <= j < height and 0 <= i < width

@njit
def set_board_empty(self, j, i):
    board[j][i] = -1

@njit
def get_id_by_pos(self, y, x):
    return board[y][x]

# Vérifie si une case est libre, sans pion
@njit
def is_empty(self, y, x):
    return board[y, x] == -1


# On récupère les mouvements réguliers, on doit vérifier que tout le trajet est libre
@njit
def get_pawn_available_regular_moves(self, nid, j, i):
    available_moves = []
    if has_movement_of(nid, 1):  # c’est un rond
        relative_moves_circle = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
        for rm in relative_moves_circle:
            dj, di = rm
            if in_board(j + dj, i + di) and is_empty(j + dj, i + di):
                available_moves += [((j, i), (dj, di))]

    if has_movement_of(nid, 2):
        r = 2
        # print(i, j)
        # print(np.equal(board[j-r:j, i], np.full((2, 3), -1)))
        # print(j, i)
        # print(in_board(j+r, i), in_board(j-r, i))
        # il y avait des 3 au lieu de length_of_data_pawn
        if in_board(j + r, i) and np.equal(board[j + 1:j + r + 1, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (r, 0))]
        if in_board(j - r, i) and np.equal(board[j - r:j, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (-r, 0))]
        if in_board(j, i + r) and np.equal(board[j, i + 1:i + r + 1],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (0, r))]
        if in_board(j, i - r) and np.equal(board[j, i - r:i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (0, -r))]

    if has_movement_of(nid, 3):
        r = 3
        if in_board(j + r, i) and np.equal(board[j + 1:j + r + 1, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (r, 0))]
        if in_board(j - r, i) and np.equal(board[j - r:j, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (-r, 0))]
        if in_board(j, i + r) and np.equal(board[j, i + 1:i + r + 1],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (0, r))]
        if in_board(j, i - r) and np.equal(board[j, i - r:i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            available_moves += [((j, i), (0, -r))]

    return available_moves

@njit
def has_pawn_available_regular_moves(self, nid):
    (j, i) = locations[nid]
    if has_movement_of(nid, 1):  # c’est un rond
        relative_moves_circle = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
        for rm in relative_moves_circle:
            dj, di = rm
            if in_board(j + dj, i + di) and is_empty(j + dj, i + di):
                return True

    if has_movement_of(nid, 2):
        r = 2
        # print(i, j)
        # print(np.equal(board[j-r:j, i], np.full((2, 3), -1)))
        # print(j, i)
        # print(in_board(j+r, i), in_board(j-r, i))
        # il y avait des 3 au lieu de length_of_data_pawn
        if in_board(j + r, i) and np.equal(board[j + 1:j + r + 1, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True
        if in_board(j - r, i) and np.equal(board[j - r:j, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True
        if in_board(j, i + r) and np.equal(board[j, i + 1:i + r + 1],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True
        if in_board(j, i - r) and np.equal(board[j, i - r:i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True

    if has_movement_of(nid, 3):
        r = 3
        if in_board(j + r, i) and np.equal(board[j + 1:j + r + 1, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True
        if in_board(j - r, i) and np.equal(board[j - r:j, i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True
        if in_board(j, i + r) and np.equal(board[j, i + 1:i + r + 1],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True
        if in_board(j, i - r) and np.equal(board[j, i - r:i],
                                                np.full((r, length_of_data_pawn), -1)).all():
            return True

    return False

# On récupère les mouvements irréguliers, juste à vérifier que la case finale est libre
@njit
def get_pawn_available_irregular_moves(self, nid, j, i):
    available_moves = []
    
    for u in [-1, 1]:  # décalage de 1
        if has_movement_of(nid, 2):
            r = 2
            if in_board(j + r, i + u) and is_empty(j + r, i + u):
                available_moves += [((j, i), (r, u))]
            if in_board(j - r, i + u) and is_empty(j - r, i + u):
                available_moves += [((j, i), (-r, u))]
            if in_board(j + u, i + r) and is_empty(j + u, i + r):
                available_moves += [((j, i), (u, r))]
            if in_board(j + u, i - r) and is_empty(j + u, i - r):
                available_moves += [((j, i), (u, -r))]

        if has_movement_of(nid, 3):
            r = 3
            if in_board(j + r, i + u) and is_empty(j + r, i + u):
                available_moves += [((j, i), (r, u))]
            if in_board(j - r, i + u) and is_empty(j - r, i + u):
                available_moves += [((j, i), (-r, u))]
            if in_board(j + u, i + r) and is_empty(j + u, i + r):
                available_moves += [((j, i), (u, r))]
            if in_board(j + u, i - r) and is_empty(j + u, i - r):
                available_moves += [((j, i), (u, -r))]

    return available_moves

@njit
def get_game_available_moves(self):
    available_moves = []  # 1 move = 2 couples (y, x)
    # pour toutes les cases non vides, on ajoute ses coups possibles dans la liste des coups
    
    ids = BLACK_ID if player_turn else WHITE_ID #Si c'est le joueur 1: blanc, sinon noir
    
    for i in ids:
        if not is_alive(i):
            continue
        (y, x) = locations[i]
        available_moves += get_pawn_available_regular_moves(i, y, x)
        available_moves += get_pawn_available_irregular_moves(i, y, x)
    
    return available_moves

@njit
def update_fast_move(self, i):
    value = value_by_id[i]
    form = form_by_id[i]
    team = team_by_id[i]
    if is_alive(i):
        (y, x) = locations[i]
        fast_moves[i] = get_pawn_available_regular_moves((value, form, team, i), y, x) + get_pawn_available_irregular_moves((value, form, team, i), y, x)
    else:
        fast_moves[i] = []
@njit
def init_fast_moves(self):
    for i in range(initial_number_of_real_pieces):
        update_fast_move(i)

@njit
def update_fast_moves(self):
    ((old_y, old_x), (current_y, current_x)) = last_move
    neighbours = np.unique(get_pieces_to_check_for_siege(old_y, old_x) + get_pieces_to_check_for_siege(current_y, current_x) + board[current_y][current_x])
    for i in neighbours:
        if i < FIRST_FAKE_ID_WHITE:
            update_fast_move(i)

@njit
def get_value_fast_moves(self):
    for i in range(initial_number_of_real_pieces):
        if i < FIRST_FAKE_ID_WHITE and is_alive(i):
            for coup in fast_moves[i]:
                yield coup


@njit
def is_alive(self, nid):
    return locations[nid] != -1

# permet de déplacer une pièce
@njit
def move_piece(self, rel_move):
    ((y, x), (dy, dx)) = rel_move
    nid = board[y][x]

    # Déplace la pièce
    board[y + dy][x + dx] = board[y][x]
    board[y][x] = -1
    # Enregistre le coup
    last_move = ((y, x), (y + dy, x + dx))
    if save_game:
        move_history.append(((y, x), (y + dy, x + dx)))

    # Met à jour pour aim/shooter
    locations[board[y + dy][x + dx]] = (y + dy, x + dx)  # je trouve ça fun comme ligne
    #print(y+dy, x+dx)
    moves_by_id[board[y + dy][x + dx]][turn] = (y + dy, x + dx)
    if nid == ID_WHITE_PYRAMID:
        for i in FAKE_ID_WHITE:
            if is_alive(i):
                locations[i] = locations[ID_WHITE_PYRAMID]
    if nid == ID_BLACK_PYRAMID:
        for i in FAKE_ID_BLACK:
            if is_alive(i):
                locations[i] = locations[ID_BLACK_PYRAMID]

    # Met à jour pour check_end
    if team_by_id[nid] == 0:
        # S’il est dans l’équipe blanche
        if y >= 8 and y + dy <= 7:
            # il vient de rentrer
            pieces_in_opponent_site[0].append(nid)

        if y <= 7 and y + dy >= 8:
            # il vient de sortir
            pieces_in_opponent_site[0].remove(nid)

    if team_by_id[nid] == 1:
        # S’il est dans l’équipe noire
        if y <= 7 and y + dy >= 8:
            # il vient de rentrer
            pieces_in_opponent_site[1].append(nid)

        if y >= 8 and y + dy <= 7:
            # il vient de sortir
            pieces_in_opponent_site[1].remove(nid)

@njit
def end_turn(self):
    turn += 1
    player_turn = (player_turn + 1) % 2

@njit
def kill(self, nid):
    if not is_alive(nid):
        return
    # si il est en vie
    if nid < FIRST_FAKE_ID_WHITE:
        # si c’est une attaque "totale"
        (y, x) = locations[nid]
        set_board_empty(y, x)
        for floor_n in develop_pyramid(nid):
            reset_links_of_pawn(floor_n)
            locations[floor_n] = -1
        moves_by_id[nid][turn] = (-1)
        # On la retire des pièces pouvant faire gagner
        for team in [0, 1]:
            if nid in pieces_in_opponent_site[team]:
                pieces_in_opponent_site[team].remove(nid)
        return
    # si c’est une attaque partielle
    reset_links_of_pawn(nid)
    locations[nid] = -1

    if nid in FAKE_ID_WHITE:
        value_by_id[ID_WHITE_PYRAMID] -= value_by_id[nid]
        floor_pyramid_white = 0
        for i in FAKE_ID_WHITE:
            if is_alive(i):
                floor_pyramid_white += 1
        if floor_pyramid_white == 0:
            kill(ID_WHITE_PYRAMID)
    if nid in FAKE_ID_BLACK:
        value_by_id[ID_BLACK_PYRAMID] -= value_by_id[nid]
        floor_pyramid_black = 0
        for i in FAKE_ID_BLACK:
            if is_alive(i):
                floor_pyramid_black += 1
        if floor_pyramid_black == 0:
            kill(ID_BLACK_PYRAMID)

@njit
def execute_all_attacks(self, attacks):
    for attack in attacks:
        (type_attack, attackers, attacked) = attack
        kill(attacked)

@njit
def set_win(self, n, way):
    print("GAGNE", n)
    stop = True
    winner = n
    way_to_win = way

@njit
def get_new_all_neighbours_id_with_directions(self, y, x, not_considered=None):
    if not_considered is None:
        not_considered = []
    neighbours = {}
    #

@njit
def get_all_neighbours_id_with_directions(self, y, x, not_considered=None):
    if not_considered is None:
        not_considered = []
    neighbours = {}
    # for direction in ["s", "n", "o", "e", "no", "ne", "so", "se"]:
    #   neighbours[direction] = (-1, -1, -1)
    for ay in range(y + 1, 16):
        if not is_empty(ay, x) and (ay, x) not in not_considered:
            neighbours["s"] = board[ay][x]
            break
    for ay in range(y - 1, -1, -1):
        if not is_empty(ay, x) and (ay, x) not in not_considered:
            neighbours["n"] = board[ay][x]
            break
    for ax in range(x + 1, 8):
        if not is_empty(y, ax) and (y, ax) not in not_considered:
            neighbours["e"] = board[y][ax]
            break
    for ax in range(x - 1, -1, -1):
        if not is_empty(y, ax) and (y, ax) not in not_considered:
            neighbours["o"] = board[y][ax]
            break
    # UL
    for dt in range(1, 1 + min(x, y)):
        if not is_empty(y - dt, x - dt) and (y - dt, x - dt) not in not_considered:
            neighbours["no"] = board[y - dt][x - dt]
            break
    # UR
    for dt in range(1, 1 + min(7 - x, y)):
        if not is_empty(y - dt, x + dt) and (y - dt, x + dt) not in not_considered:
            neighbours["ne"] = board[y - dt][x + dt]
            break
    # DL
    for dt in range(1, 1 + min(x, 15 - y)):
        if not is_empty(y + dt, x - dt) and (y + dt, x - dt) not in not_considered:
            neighbours["so"] = board[y + dt][x - dt]
            break
    # DR
    for dt in range(1, 1 + min(7 - x, 15 - y)):
        if not is_empty(y + dt, x + dt) and (y + dt, x + dt) not in not_considered:
            neighbours["se"] = board[y + dt][x + dt]
            break
    return neighbours

@njit
def get_all_pairs_neighbours_id_with_directions(self, y, x, not_considered=None):
    if not_considered is None:
        not_considered = []
    
    # for direction in ["s", "n", "o", "e", "no", "ne", "so", "se"]:
    #   neighbours[direction] = (-1, -1, -1)
    first = None
    has_first = False
    for ay in range(y + 1, 16):
        if not is_empty(ay, x) and (ay, x) not in not_considered:
            first = board[ay][x]
            has_first = True
            break
    if has_first:
        for ay in range(y - 1, -1, -1):
            if not is_empty(ay, x) and (ay, x) not in not_considered:
                yield (first, board[ay][x])
                break
            
    has_first = False        
    for ax in range(x + 1, 8):
        if not is_empty(y, ax) and (y, ax) not in not_considered:
            first = board[y][ax]
            has_first = True
            break
    
    if has_first:
        for ax in range(x - 1, -1, -1):
            if not is_empty(y, ax) and (y, ax) not in not_considered:
                yield (first, board[y][ax])
                break
    # UL
    has_first = False
    for dt in range(1, 1 + min(x, y)):
        if not is_empty(y - dt, x - dt) and (y - dt, x - dt) not in not_considered:
            first = board[y - dt][x - dt]
            has_first = True
            break
    # UR        
    if has_first:
        for dt in range(1, 1 + min(7 - x, y)):
            if not is_empty(y - dt, x + dt) and (y - dt, x + dt) not in not_considered:
                yield (first, board[y - dt][x + dt])
                break
    # DL
    has_first = False
    for dt in range(1, 1 + min(x, 15 - y)):
        if not is_empty(y + dt, x - dt) and (y + dt, x - dt) not in not_considered:
            first = board[y + dt][x - dt]
            has_first = True
            break
    # DR
    if has_first:
        for dt in range(1, 1 + min(7 - x, 15 - y)):
            if not is_empty(y + dt, x + dt) and (y + dt, x + dt) not in not_considered:
                yield (first, board[y + dt][x + dt])


@njit
def check_end(self):
    for team in [0, 1]:
        pieces_in_opponent_site = pieces_in_opponent_site[team]
        if len(pieces_in_opponent_site) > 2:
            for piece in pieces_in_opponent_site:
                # faire des triangles ou ligne qui ne sont pas en diagonal
                (y, x) = locations[piece]
                neighbours = get_all_neighbours_id_with_directions(y, x)
                available_neighbours = []

                for direction in ["n", "s", "o", "e"]:
                    if not direction in neighbours:
                        continue
                    neighbour = neighbours[direction]
                    if neighbour in pieces_in_opponent_site:
                        available_neighbours.append(neighbour)
                # print("voisins gardés: ", neighbours)


                #print("Actual: ", piece)
                #print("DEBUG: nei, ava", neighbours, available_neighbours)
                #print("will test", couple_develop_pyramid(available_neighbours))

                n = len(neighbours)
                if n < 2:
                    continue
                # print("ici")
                value_piece = value_by_id[piece]
                for ally1, ally2 in couple_develop_pyramid(available_neighbours):
                    # Toutes les combinaisons
                    value_ally1 = value_by_id[ally1]
                    value_ally2 = value_by_id[ally2]
                    #if winner != -1:
                        #print("test: ", ally1, ally2, ":", value_piece, value_ally1, value_ally2)

                    if get_progression(value_piece, value_ally1, value_ally2) > 0:
                        #print("NEWWWWWW Gagnant:", team, value_piece, value_ally1, value_ally2)
                        #print("Actual: ", piece)
                        #print("DEBUG: nei, ava", neighbours, available_neighbours)
                        #print("will test", couple_develop_pyramid(available_neighbours))
                        set_win(team, 0)
                        return

                # En diagonale
                for dir1, dir2 in [("no", "se"), ("ne", "so")]:
                    if not(dir1 in neighbours and dir2 in neighbours and neighbours[dir1] in pieces_in_opponent_site and neighbours[dir2] in pieces_in_opponent_site):
                        continue
                    #print("test diag", dir1, dir2, couple_develop_pyramid([neighbours[dir1], neighbours[dir2]]))
                    for ally1, ally2 in couple_develop_pyramid([neighbours[dir1], neighbours[dir2]]):
                        # Toutes les combinaisons
                        value_ally1 = value_by_id[ally1]
                        value_ally2 = value_by_id[ally2]
                        if get_progression(value_piece, value_ally1, value_ally2) > 0:
                            # print("NEWWWWWW Gagnant diagonal :", team, value_piece, value_ally1, value_ally2)
                            set_win(team, 1)
                            return

@njit
def set_aim(self, nid: int, melee: list, ranged: list):
    aim[nid] = [melee, ranged]

@njit
def reset_aim(self, nid):
    aim[nid] = [[], []]

@njit
def add_melee_aim(self, nid: int, melee_id: int):
    aim[nid][0].append(melee_id)

@njit
def add_ranged_aim(self, nid: int, ranged_id: int):
    aim[nid][1].append(ranged_id)

@njit
def get_all_aim(self, nid: int):
    return aim[nid][0] + aim[nid][1]

@njit
def get_melee_aim(self, nid: int):
    return aim[nid][0]

@njit
def get_ranged_aim(self, nid: int):
    return aim[nid][1]

@njit
def set_shooter(self, nid: int, melee: list, ranged: list):
    shooter[nid] = [melee, ranged]

@njit
def reset_shooter(self, nid):
    shooter[nid] = [[], []]

@njit
def add_melee_shooter(self, nid: int, melee_id: int):
    shooter[nid][0].append(melee_id)

@njit
def add_ranged_shooter(self, nid: int, ranged_id: int):
    shooter[nid][1].append(ranged_id)

@njit
def get_all_shooter(self, nid):
    # print("get all shooter:")
    # print(shooter[nid][0])
    # print(shooter[nid][1])
    # print(shooter[nid][0] + shooter[nid][1])
    return shooter[nid][0] + shooter[nid][1]

@njit
def get_melee_shooter(self, nid):
    return shooter[nid][0]

@njit
def get_ranged_shooter(self, nid):
    return shooter[nid][1]

@njit
def remove_nid_from_mid_aim(self, nid, mid):
    # retire nid de la visée de mid
    if nid in aim[mid][0]:
        # print("remove ", nid, " from ", mid, " aim melee")
        aim[mid][0].remove(nid)
    if nid in aim[mid][1]:
        # print("remove ", nid, " from ", mid, " aim ranged")
        aim[mid][1].remove(nid)

@njit
def remove_nid_from_mid_shooter(self, nid, mid):
    # retire nid comme attaquant mid
    if nid in shooter[mid][0]:
        # print("remove ", nid, " from ", mid, " shooter melee")
        shooter[mid][0].remove(nid)
    if nid in shooter[mid][1]:
        # print("remove ", nid, " from ", mid, " shooter ranged")
        shooter[mid][1].remove(nid)



@njit
def set_attack_defense(self):
    # initialise le dictionnaire
    
    aim = nb.typed.Dict.empty(key_type=types.int64, value_type=types.ListType(types.int64[:]))
    shooter = nb.typed.Dict.empty(key_type=types.int64, value_type=types.ListType(types.int64[:]))

@njit
def set_moves_by_id(self):
    for i in range(initial_number_of_real_pieces):
        moves_by_id[i] = {-1: locations[i]}



@njit
def reset_links_of_pawn(self, nid):
    # doit modifier aim et targeted_by
    for aim in get_all_aim(nid):
        # n tire sur aim
        # donc aim est visé par n, ie n est un shooter de aim
        remove_nid_from_mid_shooter(nid, aim)
    # print("reset aim ", nid)
    reset_aim(nid)

    for shooter in get_all_shooter(nid):
        # print("reset shooter", nid, shooter, get_all_shooter(nid))
        # shooter tire sur n, du moins tirait
        remove_nid_from_mid_aim(nid, shooter)
    # print("reset shooter ", nid)
    reset_shooter(nid)

@njit
def add_line(self, nid, mid):
    # c’est une ligne d’attaque, deux pièces vont maintenant "se voir"

    if team_by_id[nid] == team_by_id[mid]:
        return  # deux pièces d’une même équipe ne veulent pas se tuer

    (ny, nx) = locations[nid]
    (my, mx) = locations[mid]
    nvalue = value_by_id[nid]
    mvalue = value_by_id[mid]
    # print("continue add_line")
    dist = max(abs(ny - my), abs(nx - mx)) - 1  # espace entre les deux
    # print("dist ", dist, ny, nx, my, mx)
    if dist >= 2 and a_is_equation(mvalue, dist, nvalue):
        # print("attaque de loin", turn)
        # n attaque m de loin
        add_ranged_aim(nid, mid)
        add_ranged_shooter(mid, nid)

        # Donc m attaque n de loin
        add_ranged_aim(mid, nid)
        add_ranged_shooter(nid, mid)

    same_line_or_column = min(abs(ny - my), abs(nx - mx)) == 0
    # print("turn", turn, same_line_or_column)
    # on regarde si n attaque m en mêlée, puis si m attaque n en mêlée
    for aid, bid in [(nid, mid), (mid, nid)]:
        if has_movement_of(nid, 1):  # c’est un rond
            if (not same_line_or_column) and dist == 0:  # s’il attaque en vertical juste à côté de lui
                add_melee_aim(aid, bid)
                add_melee_shooter(bid, aid)
                # print("melee ", aid, bid)

        if has_movement_of(nid, 2):
            if same_line_or_column and dist == 1:
                add_melee_aim(aid, bid)
                add_melee_shooter(bid, aid)
                # print("melee ", aid, bid)

        if has_movement_of(nid, 3):
            if same_line_or_column and dist == 2:
                add_melee_aim(aid, bid)
                add_melee_shooter(bid, aid)
                # print("melee ", aid, bid)

@njit
def update_aim_shooter(self):
    #même fonctio nque update_aim_shooter, mais si il n'y a personne au nord, il ne va pas chercher ce qu'il y a au sud
    (old_y, old_x), (current_y, current_x) = last_move
    nid = board[current_y][current_x] # identifiant de la pièce déplacée
    # print("------------------------------------------")
    # print("Tour: ", turn)
    # print(aim)
    # print(shooter)
    # print("Début tour, pièce: ", nid)

    # !!! Dans toute cette partie de code, la pièce est déjà posée au nouvel endroit !!!

    # on considère la disparition de la pièce
    # elle n’est plus attaquée et n’attaque plus
    # print("-- 1 --")
    for floor_n in develop_pyramid(nid):
        reset_links_of_pawn(floor_n) #1000: + 1 sec

    # print("-- 2 --")
    # Puis, on ajoute les nouveaux voisins causés par la disparition de la pièce
    
    neighbours = get_all_pairs_neighbours_id_with_directions(old_y, old_x, not_considered=[(current_y, current_x)])

    # print(neighbours)
    for (a_id, b_id) in neighbours:
        
            # a et b peuvent être des pyramides
            for floor_a in develop_pyramid(a_id):
                for floor_b in develop_pyramid(b_id):
                    add_line(floor_a, floor_b)
    # On considère l’arrivée de la pièce
    # les pièces nord-sud ne se touchent plus, etc...

    # print("-- 3 --")
    neighbours = get_all_neighbours_id_with_directions(current_y, current_x)
    for (d1, d2) in [("n", "s"), ("ne", "so"), ("e", "o"), ("se", "no")]:
        if d1 in neighbours and d2 in neighbours:
            aid = neighbours[d1]
            bid = neighbours[d2]
            for floor_a in develop_pyramid(aid):
                for floor_b in develop_pyramid(bid):
                    remove_nid_from_mid_aim(floor_a, floor_b)
                    remove_nid_from_mid_aim(floor_b, floor_a)
                    remove_nid_from_mid_shooter(floor_a, floor_b)
                    remove_nid_from_mid_shooter(floor_b, floor_a)

    # Mais la pièce va toucher ses voisins

    # print("-- 4 --")
    for direction in ["n", "s", "e", "o", "ne", "no", "se", "so"]:
        if direction in neighbours:
            bid = neighbours[direction]

            for floor_n in develop_pyramid(nid):
                for floor_b in develop_pyramid(bid):
                    add_line(floor_n, floor_b)

@njit
def old_update_aim_shooter(self):
    (old_y, old_x), (current_y, current_x) = last_move
    nid = board[current_y][current_x] # identifiant de la pièce déplacée
    # print("------------------------------------------")
    # print("Tour: ", turn)
    # print(aim)
    # print(shooter)
    # print("Début tour, pièce: ", nid)

    # !!! Dans toute cette partie de code, la pièce est déjà posée au nouvel endroit !!!

    # on considère la disparition de la pièce
    # elle n’est plus attaquée et n’attaque plus
    # print("-- 1 --")
    for floor_n in develop_pyramid(nid):
        reset_links_of_pawn(floor_n) #1000: + 1 sec

    # print("-- 2 --")
    # Puis, on ajoute les nouveaux voisins causés par la disparition de la pièce
    
    neighbours = get_all_neighbours_id_with_directions(old_y, old_x, not_considered=[(current_y, current_x)])
    # print(neighbours)
    for (d1, d2) in [("n", "s"), ("ne", "so"), ("e", "o"), ("se", "no")]:
        if d1 in neighbours and d2 in neighbours:
            a_id = neighbours[d1]
            b_id = neighbours[d2]
            # a et b peuvent être des pyramides
            for floor_a in develop_pyramid(a_id):
                for floor_b in develop_pyramid(b_id):
                    add_line(floor_a, floor_b)
    # On considère l’arrivée de la pièce
    # les pièces nord-sud ne se touchent plus, etc...

    # print("-- 3 --")
    neighbours = get_all_neighbours_id_with_directions(current_y, current_x)
    for (d1, d2) in [("n", "s"), ("ne", "so"), ("e", "o"), ("se", "no")]:
        if d1 in neighbours and d2 in neighbours:
            aid = neighbours[d1]
            bid = neighbours[d2]
            for floor_a in develop_pyramid(aid):
                for floor_b in develop_pyramid(bid):
                    remove_nid_from_mid_aim(floor_a, floor_b)
                    remove_nid_from_mid_aim(floor_b, floor_a)
                    remove_nid_from_mid_shooter(floor_a, floor_b)
                    remove_nid_from_mid_shooter(floor_b, floor_a)

    # Mais la pièce va toucher ses voisins

    # print("-- 4 --")
    for direction in ["n", "s", "e", "o", "ne", "no", "se", "so"]:
        if direction in neighbours:
            bid = neighbours[direction]

            for floor_n in develop_pyramid(nid):
                for floor_b in develop_pyramid(bid):
                    add_line(floor_n, floor_b)

@njit
def old_set_locations(self):
    for y in range(16):
        for x in range(8):
            if not is_empty(y, x):
                locations[board[y][x]] = (y, x)
    for i in FAKE_ID_BLACK:
        locations[i] = locations[ID_BLACK_PYRAMID]
    for i in FAKE_ID_WHITE:
        locations[i] = locations[ID_WHITE_PYRAMID]
    # print(locations)

@njit
def set_locations(self):
    for y in range(16):
        for x in range(8):
            if not is_empty(y, x):
                locations[board[y][x]] = np.array([y, x], dtype=np.int32)
    for i in FAKE_ID_BLACK:
        locations[i] = locations[ID_BLACK_PYRAMID]
    for i in FAKE_ID_WHITE:
        locations[i] = locations[ID_WHITE_PYRAMID]

# en fait c’est nul ça, si la pyramide attaque ça ne veut pas dire que toutes les pièces attaquent
@njit
def develop_pyramid(self, nid):
    # Argument : des identifiants
    # Sortie : les identifiants, et tous les identifiants de la pyramide si elle y est
    res = [nid]
    if ID_WHITE_PYRAMID == nid:
        for i in FAKE_ID_WHITE:
            if is_alive(i):
                res.append(i)
    if ID_BLACK_PYRAMID == nid:
        for i in FAKE_ID_BLACK:
            if is_alive(i):
                res.append(i)

    return res



@njit
def develop_list_pyramid(self, pieces):
    res = []
    for piece in pieces:
        res += develop_pyramid(piece)
    return res    

# à revoir, idée bonne mais même problème que la fonction au dessus
@njit
def couple_develop_pyramid(self, id_pieces: list[int]):
    #if winner!=-1:
        # print("id_picees", id_pieces, develop_list_pyramid(id_pieces))
    id_pieces = develop_list_pyramid(id_pieces)  # on ne récupère que les étages dans le jeu
    for i in range(len(id_pieces)):
        for j in range(i):
            # il faut que ce soit deux pièces différentes (i!=j) ok
            # et que si i est une pyramide, j ne peut pas faire partie de la pyramide, si i est une partie de pyramide, j ne peut pas l’être
            # Rappel : ce sont des combinaisons ok
            piece_i = id_pieces[i]
            piece_j = id_pieces[j]
            if piece_i == ID_WHITE_PYRAMID and piece_j in FAKE_ID_WHITE:
                continue
            if piece_j == ID_WHITE_PYRAMID and piece_i in FAKE_ID_WHITE:
                continue
            if piece_i == ID_BLACK_PYRAMID and piece_j in FAKE_ID_BLACK:
                continue
            if piece_j == ID_BLACK_PYRAMID and piece_i in FAKE_ID_BLACK:
                continue
            if piece_j in FAKE_ID_BLACK and piece_i in FAKE_ID_BLACK:
                continue
            if piece_j in FAKE_ID_WHITE and piece_i in FAKE_ID_WHITE:
                continue
            yield (piece_i, piece_j)


@njit
def get_attacks_with_aim_shooter(self): 
    #! Pas possible de yield ni set car il y a des listes à l'intérieur
    attacks = []
    # attaque de mêlée
    # attaque MEET et GALLOWS
    for n_piece in range(initial_number_of_pieces):
        if team_by_id[n_piece] == player_turn:
            continue
        # pour toutes les pièces et partie de pyramide
        if locations[n_piece] == -1:  # Si cette pièce est encore en jeu
            continue
        n_value = value_by_id[n_piece]
        melee_shooters = get_melee_shooter(n_piece)

        # MEET/GALLOWS
        for s in melee_shooters:
            s_value = value_by_id[s]
            if n_value == s_value:
                attacks.append((TypeAttack.MEET, [s], n_piece))

            elif is_power_or_root(n_value, s_value):
                attacks.append((TypeAttack.GALLOWS, [s], n_piece))

        # AMBUSH, PROGRESSION on prend tous les 2 parmis n
        for shooter_i, shooter_j in couple_develop_pyramid(melee_shooters):
            attack = a_is_equation(value_by_id[n_piece], value_by_id[shooter_i],
                                    value_by_id[shooter_j])
            if attack:
                attacks.append((TypeAttack.AMBUSH, [shooter_i, shooter_j], n_piece))

            pro = get_progression(value_by_id[n_piece], value_by_id[shooter_i],
                                    value_by_id[shooter_j])
            if pro > 0:
                if pro == 1:
                    attacks.append(
                        (TypeAttack.PROGRESSION_A, [shooter_i, shooter_j], n_piece))
                if pro == 2:
                    attacks.append(
                        (TypeAttack.PROGRESSION_G, [shooter_i, shooter_j], n_piece))
                if pro == 3:
                    attacks.append(
                        (TypeAttack.PROGRESSION_H, [shooter_i, shooter_j], n_piece))
        # ASSAULT
        for shooter_i in get_ranged_shooter(n_piece):
            attacks.append((TypeAttack.ASSAULT, [shooter_i], n_piece))
    return attacks



@njit
def check_pyramid_has_form(self, nid, required_form):
    if nid == ID_WHITE_PYRAMID:
        first = FIRST_FAKE_ID_WHITE + required_form * 2
        second = first + 1
        return is_alive(first) or is_alive(second)

    if nid == ID_BLACK_PYRAMID:
        if required_form == 0:
            return is_alive(FIRST_FAKE_ID_BLACK)
        else:
            first = FIRST_FAKE_ID_WHITE + required_form * 2 - 1
            second = first + 1
            return is_alive(first) or is_alive(second)

@njit
def has_movement_of(self, nid, required_form):
    form = form_by_id[nid]
    return form == required_form or (form == 4 and check_pyramid_has_form(nid, required_form))

@njit
def get_pieces_to_check_for_siege(self, y, x):
        
        # for direction in ["s", "n", "o", "e", "no", "ne", "so", "se"]:
        #   neighbours[direction] = (-1, -1, -1)
        for ay in range(y + 1, min(y + 3 + 1, 16)):
            if not is_empty(ay, x):
                # il y a une pièce
                check_id = board[ay][x]
                if has_movement_of(check_id, 2) or has_movement_of(check_id, 3):
                    yield check_id
                break
        for ay in range(y - 1, max(y - 3 - 1, -1), -1):
            if not is_empty(ay, x):
                check_id = board[ay][x]
                if has_movement_of(check_id, 2) or has_movement_of(check_id, 3):
                    yield check_id
                break
        for ax in range(x + 1, min(x + 3 + 1, 8)):
            if not is_empty(y, ax):
                check_id = board[y][ax]
                if has_movement_of(check_id, 2) or has_movement_of(check_id, 3):
                    yield check_id
                break
        for ax in range(x - 1, max(x - 3 - 1, -1), -1):
            if not is_empty(y, ax):
                check_id = board[y][ax]
                if has_movement_of(check_id, 2) or has_movement_of(check_id, 3):
                    yield check_id
                break
        # diag
        for dt in [(-1, -1), (-1, 1), (1, 1), (1, -1)]:
            dy, dx = dt
            if in_board(y + dy, x + dx) and not is_empty(y + dy, x + dx):
                check_id = board[y + dy][x + dx]
                if has_movement_of(check_id, 1):
                    yield check_id

@njit
def detect_siege(self):
    attacks = []
    (_, _), (current_y, current_x) = last_move
    neighbours = get_pieces_to_check_for_siege(current_y, current_x)
    center_id = get_id_by_pos(current_y, current_x)
    team = team_by_id[center_id]

    for nid in neighbours:

        if team != team_by_id[nid] and not has_pawn_available_regular_moves(nid):
            attacks.append((TypeAttack.SIEGE, [center_id], nid))
    return attacks

@njit
def init():
    start_time = time.time()
    #board = np.zeros((16, 8), dtype=np.int32)

    board = np.array([[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [0, 1, -1, -1, -1, -1, 2, 3], [4, 5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18, 19], [-1, -1, 20, 21, 22, 23, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, 24, 25, 26, 27, -1, -1], [28, 29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42, 43], [44, 45, -1, -1, -1, -1, 46, 47], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]])

    turn = 0
    player_turn = 0
    width = 8
    height = 16
    stop = False
    last_move = np.zeros((2, 2), dtype=np.int32)
    save_game = True
    move_history = types.List.empty_list(int32[:, :])
    game_attacks = types.List.empty_list(types.ListType(int32[:]))
    locations = types.Dict.empty(key_type=int32, value_type=int32[:])
    aim = types.Dict.empty(key_type=int32, value_type=nb.typed.List.empty_list(int32[:]))
    shooter = types.Dict.empty(key_type=int32, value_type=nb.typed.List.empty_list(int32[:]))

    value_by_id = np.array([49, 121, 225, 163, 28, 66, 36, 30, 59, 64, 120, 190, 16, 12, 9, 25, 49, 81, 90, 100, 3, 5, 7, 9, 8, 6, 4, 2, 81, 72, 64, 36, 16, 4, 6, 9, 153, 91, 49, 42, 20, 25, 45, 15, 289, 169, 81, 25, 1, 4, 9, 16, 25, 36, 16, 25, 36, 49, 64], dtype=np.int32)
    form_by_id = np.array([3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 4, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 3, 4, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 3, 3, 1, 2, 2, 3, 3], dtype=np.int32)
    team_by_id = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], dtype=np.int32)
    moves_by_id = nb.typed.Dict.empty(key_type=int32, value_type=nb.typed.Dict.empty(key_type=int32, value_type=int32[:]))
    pieces_in_opponent_site = np.zeros((2, 24), dtype=np.int32)
    winner = -1
    initial_number_of_real_pieces = 48
    initial_number_of_pieces = 59
    ID_WHITE_PYRAMID = 37
    ID_BLACK_PYRAMID = 11

    BLACK_ID = np.array(list(range(0, 24)))
    WHITE_ID = np.array(list(range(24, 48)))

    FAKE_ID_WHITE = np.array(list(range(48, 53 + 1)), dtype = int32)
    FIRST_FAKE_ID_WHITE = FAKE_ID_WHITE[0]
    FAKE_ID_BLACK = np.array(list(range(54, 58 + 1)), dtype = int32)
    FIRST_FAKE_ID_BLACK = FAKE_ID_BLACK[0]
    set_locations()
    #set_attack_defense()
    set_moves_by_id()

@njit
def play_move(self, move):
    #for i in range(1000):
    pre_aim_attacks = get_attacks_with_aim_shooter() # 1000 + 13s
    
    # print(j, len(coups))

    #value_fast_move = get_value_fast_moves()
    #if len(coups) != len(value_fast_move):
    #    print("ERROR", len(coups), len(value_fast_move))
    
    move_piece(move)
    #update_fast_moves()
    #for i in range(1000):
    update_aim_shooter()  # 1000 + 100 secondes (?)
    # detect_siege 1000 + 20s
    aim_attacks = get_attacks_with_aim_shooter() + detect_siege()

    available_aim_attacks = aim_attacks
    for no in pre_aim_attacks:
        if no in aim_attacks:
            available_aim_attacks.remove(no)
        
    # for i in available_aim_attacks:
    #    print("AIMSHOOTER detects ", turn, ": ", str(i))

    
    game_attacks.append([])
    game_attacks[turn] = available_aim_attacks
    execute_all_attacks(available_aim_attacks)

    
    #for i in range(1000):
    check_end() # moyen, +100sec/1000 exe par boucle
    end_turn()




        




print(f"FINAL TIME: {c:.3}s")

